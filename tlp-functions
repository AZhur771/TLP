#!/bin/sh
# tlp - power management functions

# ----------------------------------------------------------------------------
# Definitions
TLPVER="0.2.8.100 (DEBUG)"
DEFAULT_FILE=/etc/default/tlp
ACPWR=/usr/bin/on_ac_power
ETHTOOL=/usr/sbin/ethtool
HDPARM=/sbin/hdparm
IWC=/sbin/iwconfig
MODPRO=/sbin/modprobe
UDEVADM=/sbin/udevadm
SMAPI=tp_smapi
SMAPIDIR=/sys/devices/platform/smapi
LOGGER=/usr/bin/logger
USBD=/sys/bus/usb/devices
USB_BLACKLIST_INT=""
USB_TIMEOUT=2
NETD=/sys/class/net

# ----------------------------------------------------------------------------
# Functions

patinstr () { # $1: pattern, $2: target -- test if pattern matches part of target
	[ -n "$1" -a -n "$2" -a "$2" != "${2#*$1}" ]
	return $?
}

echo_debug () { # $1: tag; $2: msg; echo debug msg if tag matches 
	if patinstr "$1" "$TLP_DEBUG"; then
		$LOGGER -p debug -t "tlp[$$,$PPID]" "$2"
	fi
}

check_sysfs ()  { # $1: routine; $2: sysfs path
	if patinstr "sysfs" "$TLP_DEBUG"; then
		if [ ! -e $2 ]; then
			$LOGGER -p debug -t "tlp[$$]" "$1:$2 nonexistent"
		fi
	fi
}

check_root () { 
	if [ "$(id -u)" != "0" ]; then
		echo "Error: root privilege needed. Please call me with 'sudo'." 1>&2
		exit 1
	fi
}

check_tlp_enabled () { # ret: 0=disabled/1=enabled
	if [ ! "$TLP_ENABLE" = "1" ]; then
		echo "Error: tlp power save is disabled; set TLP_ENABLE=1 in /etc/default/tlp." 1>&2
		return 1
	else
		return 0
	fi
}

check_laptop_mode_tools () { # ret: 0=disabled, 1=enabled
	[ -f /etc/default/acpi-support ] && . /etc/default/acpi-support
	if [ "$ENABLE_LAPTOP_MODE" = "true" -o -f /var/run/laptop-mode-tools/enabled ]; then
		echo "Error: tlp power save is disabled because laptop-mode-tools is active." 1>&2
		echo "       Set ENABLE_LAPTOP_MODE=false in /etc/default/acpi-support." 1>&2
		echo 1>&2
		echo_debug "pm" "check_laptop_mode_tools: yes" 
		return 1
	else
		return 0
	fi
}

read_defaults () {
	if [ -f $DEFAULT_FILE ]; then
		. $DEFAULT_FILE
	fi
	
	return 0
}

load_tp_smapi () {
	$MODPRO $SMAPI > /dev/null 2>&1 
	
	return 0
}

get_power_state () { # ret: 0=ac, 1=battery
	$ACPWR
	return $? 
}

set_laptopmode () { # $1: 0=ac mode, 1=battery mode
	check_sysfs "set_laptopmode" "/proc/sys/vm/laptop_mode"
	
	if [ "$1" = "1" ]; then
		echo_debug "pm" "set_laptopmode($1): $DISK_IDLE_SECS_ON_BAT"
		[ "${DISK_IDLE_SECS_ON_BAT:-undef}" = "undef" ] || \
		  echo $DISK_IDLE_SECS_ON_BAT > /proc/sys/vm/laptop_mode
	else
		echo_debug "pm" "set_laptopmode($1): $DISK_IDLE_SECS_ON_AC"
		[ "${DISK_IDLE_SECS_ON_AC:-undef}" = "undef" ] || \
		  echo $DISK_IDLE_SECS_ON_AC > /proc/sys/vm/laptop_mode
	fi
	
	return 0
}

set_extfs_commit () { # $1: commit
	# remount ext3/4 filesystems with commit=age (from laptop-mode-tools)
	local dev mtpoint fstype mopts d1 d2
	
	mount | while read dev d1 mtpoint d2 fstype mopts; do 
		case $fstype in
			ext[34]) 
				mopts=$(echo $mopts | sed -r 's/,commit=[0-9]+|^\(commit=[0-9]+,|\(|\)//g')
				if [ -b $dev -a -d $mtpoint ]; then
					mount $dev $mtpoint -t $fstype -o remount,$mopts,commit=$commit
				fi
				;;
			
			*)
				;;
		esac		
	done
	
	return 0
}

set_dirty_parms () { # $1: 0=ac mode, 1=battery mode
	# Some code adapted from laptop-mode-tools
	local commit age
	
	check_sysfs "set_dirty_parms" "/proc/sys/vm"
	
	if [ "$1" = "1" ]; then
		commit=${MAX_LOST_WORK_SECS_ON_BAT:-15}
	else
		commit=${MAX_LOST_WORK_SECS_ON_AC:-5}
	fi
	age=$(($commit * 100))
			
	echo_debug "pm" "set_dirty_parms($1): $commit $age"
		
	echo $age > /proc/sys/vm/dirty_writeback_centisecs
	echo $age > /proc/sys/vm/dirty_expire_centisecs
		
	set_extfs_commit $commit
		
	if [ -d /proc/sys/fs/xfs ]; then
		echo $age > /proc/sys/fs/xfs/age_buffer_centisecs
		echo $age > /proc/sys/fs/xfs/xfssyncd_centisecs
		echo 3000 > /proc/sys/fs/xfs/xfsbufd_centisecs
	fi

	echo 60 > /proc/sys/vm/dirty_ratio
	echo 1 > /proc/sys/vm/dirty_background_ratio
	
	return 0
}

set_phc_controls () { 
    local control
    
	check_sysfs "set_phc_controls" "/sys/devices/system/cpu/cpu0/cpufreq"
	
    if [ "${PHC_CONTROLS:-undef}" != "undef" ]; then 
        echo_debug "pm" "set_phc_controls: $PHC_CONTROLS"
            
        for control in /sys/devices/system/cpu/cpu*/cpufreq/phc_controls; do 
            if [ -f $control ]; then
                echo_debug "pm" "set_phc_controls: $control $PHC_CONTROLS"
                echo $PHC_CONTROLS > $control
            fi
        done
    fi
    
	return 0
}

check_disk_hdparm_cap () { # $1: dev; ret: 0=none/1=available
    if [ -z "$($HDPARM -I /dev/$1 2>&1 | grep 'Invalid exchange')" ]; then
		return 0
	else
		return 1
	fi
}

echo_disk_model () { # $1: dev
	local model
	
	model=$($HDPARM -I /dev/$1 2>&1 | grep 'Model Number' | \
	  cut -f2 -d: | sed -r 's/^ *//' )
	echo "$model"
	
	return 0
}

get_disk_apm_level () { # $1: dev; ret: apm
	local apm
	
	apm=$($HDPARM -I /dev/$1 2>&1 | grep 'Advanced power management level' | \
	      cut -f2 -d: | egrep "^ *[0-9]+ *$")
	if [ -n "$apm" ]; then
		return $apm
	else 
		return 0
	fi
}

set_disk_apm_level () { # $1: 0=ac mode, 1=battery mode
	local dev apm apmlist
	
	DISK_DEVICES=${DISK_DEVICES:=sda}
    if [ $1 = "1" ]; then
        apmlist=$DISK_APM_LEVEL_ON_BAT
    else
        apmlist=$DISK_APM_LEVEL_ON_AC
    fi
    
    # strip excess blanks from list
    apmlist=$(echo -n $apmlist | sed -r 's/ +/ /g; s/^ | $//g') 
    
    [ -z "$apmlist" ] && return 0 
    
	for dev in $DISK_DEVICES; do
		if [ -b /dev/$dev ]; then
			check_disk_hdparm_cap $dev
			if [ $? = 0 ]; then
                # parse list
                apm=$(echo -n $apmlist | sed -r 's/^(\w+) .*/\1/')
                apmlist=$(echo -n $apmlist | sed -r 's/^\w+ (.*)/\1/')
				
                echo_debug "pm" "set_disk_apm_level($1): $dev $apm"
                $HDPARM -B $apm /dev/$dev > /dev/null 2>&1
			fi
		fi
	done
	
	return 0
} 

set_sata_link_power () { # $1: 0=ac mode, 1=battery mode
	local i pwr
		
	if [ "$1" = "1" ]; then
		[ "${SATA_LINKPWR_ON_BAT:-undef}" = "undef" ] && return 0
		pwr=$SATA_LINKPWR_ON_BAT
	else
		[ "${SATA_LINKPWR_ON_AC:-undef}" = "undef" ] && return 0
		pwr=$SATA_LINKPWR_ON_AC
	fi
	echo_debug "pm" "set_sata_link_power($1): $pwr"
	
	for i in /sys/class/scsi_host/host*/link_power_management_policy ; do
		if [ -f $i ]; then
			echo "$pwr" > $i
		fi
	done
	
	return 0
} 

get_wifi_ifaces () { # retval: $WIFACES
	WIFACES=$($IWC 2> /dev/null | grep 'IEEE' | sed -r 's/^(.*)[ \t]+IEEE.*/\1/')
	
	return 0
}

get_wifi_driver () { # $1: iface; retval: $WIFIDRV
	local drvl
	
	WIFIDRV=""
	if [ -d $NETD/$1 ]; then
		drvl=$(readlink $NETD/$1/device/driver)
		[ -n "$drvl" ] && WIFIDRV=${drvl##*/}
	fi
	
	return 0
}

set_wifi_power_mode () { # $1: 0=ac mode, 1=battery mode; $2 iface
	local pwr iface
	
	if [ "$1" = "1" ]; then
		pwr=${WIFI_PWR_ON_BAT:-0}
	else
		pwr=${WIFI_PWR_ON_AC:-0}
	fi
	case $pwr in
		0|1|N) 			pwr="off" ;;
		2|3|4|5|6|Y)	pwr="on"  ;;
	esac
	
	if [ -n "$2" ]; then
		echo_debug "pm" "set_wifi_power_mode($1, $2): $pwr"		
		$IWC $2 power $pwr > /dev/null 2>&1 
	else
		get_wifi_ifaces
		
		for iface in $WIFACES; do
			echo_debug "pm" "set_wifi_power_mode($1, $iface): $pwr"
			$IWC $iface power $pwr > /dev/null 2>&1 
		done
	fi
	
	return 0
}

disable_wake_on_lan () {  
	[ "${WOL_DISABLE:-undef}" = "undef" ] && return 0
	
	if [ "$WOL_DISABLE" = "Y" ]; then
		echo_debug "pm" "disable_wake_on_lan: y"
		$ETHTOOL -s eth0 wol d > /dev/null 2>&1
	else
		echo_debug "pm" "disable_wake_on_lan: n"
		$ETHTOOL -s eth0 wol e > /dev/null 2>&1
	fi
	
	return 0
}

set_sound_power_mode () {
	[ "${SOUND_POWER_SAVE:-undef}" = "undef" ] && return 0
	
	check_sysfs "set_sound_power_mode" "/sys/module"

	if [ -d /sys/module/snd_hda_intel ]; then
		echo_debug "pm" "set_sound_power_mode.hda: $SOUND_POWER_SAVE $SOUND_POWER_SAVE_CONTROLLER"
		echo "$SOUND_POWER_SAVE" > /sys/module/snd_hda_intel/parameters/power_save
		[ "${SOUND_POWER_SAVE_CONTROLLER:-undef}" = "undef" ] || \
		  echo "$SOUND_POWER_SAVE_CONTROLLER" > /sys/module/snd_hda_intel/parameters/power_save_controller 
	fi
		
	if [ -d /sys/module/snd_ac97_codec ]; then
		echo_debug "pm" "set_sound_power_mode.ac97: $SOUND_POWER_SAVE"
		echo "$SOUND_POWER_SAVE" > /sys/module/snd_ac97_codec/parameters/power_save
	fi
	
	return 0
}

enable_usb_suspend () {
	local devices usbdev subdev level hid
	
	check_sysfs "set_usb_suspend" "$USBD"
	
	if [ "$USB_AUTOSUSPEND" = "1" ]; then
		devices=$(ls $USBD | grep -v ':')
		for usbdev in $devices; do
			if [ -f $USBD/$usbdev/power/autosuspend ]; then
				usbid="$(cat $USBD/$usbdev/idVendor):$(cat $USBD/$usbdev/idProduct)"
			
				level="auto"
                hid=""
                if patinstr "$usbid" "$USB_BLACKLIST_INT $USB_BLACKLIST"; then
                    # device is in blacklist
                    level="on"
                else
                    # check for hid subdevices
                    for subdev in $USBD/$usbdev/*:*; do
                        if [ -L $subdev/driver ]; then
                            driver=$(readlink $subdev/driver)
                            if [ "${driver##*/}" = "usbhid" ]; then
                                level="on"
                                hid="(hid)"
                                break
                            fi
                        fi
                    done    
                fi
                
                echo_debug "usb" "enable_usb_suspend.$level$hid: $USBD/$usbdev"
				echo "$level" > $USBD/$usbdev/power/level
				echo $USB_TIMEOUT > $USBD/$usbdev/power/autosuspend
			fi
		done
	fi
	
	return 0
}

do_threshold () { # $1: treshold file, $2: new value
	if [ -n "$2" ]; then
		if [ "$(cat $1)" != "$2" ]; then
			echo $2 > $1
		fi
	fi
}

set_charge_thresholds () {
	echo_debug "pm" "set_charge_thresholds"
	[ -d $SMAPIDIR ] || return 0
	echo_debug "pm" "set_charge_thresholds.smapidir-present"
	
	if [ -d $SMAPIDIR/BAT0 ] && [ "$(cat $SMAPIDIR/BAT0/installed)" = "1" ]; then
		echo_debug "pm" "set_charge_thresholds: BAT0 $START_CHARGE_THRESH_BAT0 $STOP_CHARGE_THRESH_BAT0"
		do_threshold $SMAPIDIR/BAT0/start_charge_thresh "$START_CHARGE_THRESH_BAT0"
		do_threshold $SMAPIDIR/BAT0/stop_charge_thresh "$STOP_CHARGE_THRESH_BAT0"
	fi
	if [ -d $SMAPIDIR/BAT1 ] &&  [ "$(cat $SMAPIDIR/BAT1/installed)" = "1" ]; then
		echo_debug "pm" "set_charge_thresholds: BAT1 $START_CHARGE_THRESH_BAT1 $STOP_CHARGE_THRESH_BAT1"
		do_threshold $SMAPIDIR/BAT1/start_charge_thresh "$START_CHARGE_THRESH_BAT1"
		do_threshold $SMAPIDIR/BAT1/stop_charge_thresh "$STOP_CHARGE_THRESH_BAT1"
	fi
	
	return 0
}

cancel_discharge () { # called from trap
	echo 0 > $bdir/force_discharge
	echo "\nDischarging of battery $bat cancelled."
	echo_debug "pm" "discharge_battery.cancelled: $bat"
	exit 0
}

discharge_battery () { # $1: battery
	local bat bdir
	
	if [ ! -d $SMAPIDIR ]; then
		echo_debug "pm" "discharge_battery.nosmapi: $bat"
		echo "Error: ThinkPad battery functions not available (missing tp_smapi kernel module)."
		return 1
	fi
	
	if ! get_power_state ; then
		echo_debug "pm" "discharge_battery.noacpower: $bat"
		echo "Error: discharge is possible on ac power only."
		return 1
	fi	

	bat=$1
	bat=${bat:=BAT0} # default is BAT0
	bat=$(echo $bat | tr "[:lower:]" "[:upper:]")
	bdir=$SMAPIDIR/$bat
	
	if [ ! -f $bdir/installed ] || [ "$(cat $bdir/installed)" = "0" ]; then
		echo_debug "pm" "discharge_battery.notpresent: $bat"
		echo "Error: battery $bat not present."
		return 1
	fi
		
	echo 1 > $bdir/force_discharge
	trap cancel_discharge INT
	
	while [ "$(cat $bdir/force_discharge)" = "0" ]; do :; done
	echo_debug "pm" "discharge_battery.running: $bat"

	while [ "$(cat $bdir/force_discharge)" = "1" ]; do
		clear
		echo "Currently discharging battery $bat:"
		echo "voltage            = $(cat $bdir/voltage) [mV]"
		echo "remaining percent  = $(cat $bdir/remaining_percent) [%]"
		echo "remaining capacity = $(cat $bdir/remaining_capacity) [mWh]"
		echo "remaining time     = $(cat $bdir/remaining_running_time_now) [min]"
		echo "Press Ctrl+C to cancel."
		sleep 2
	done

	echo
	echo "Done: battery $bat was completely discharged."
	echo_debug "pm" "discharge_battery.complete: $bat"
	return 0
}

thresh_check () { # $1: threshold; ret: 0=invalid/1..100=valid
	local thr
	
	thr=$(echo $1 | egrep '^[0-9]{1,3}$') # check for 1..3 digits
	[ -z "$thr"  ] && thr=0 
	[ $thr -gt 100 ] && thr=0 
	
	return $thr
}

setcharge_battery () { # $1: start charge threshold, $2: stop charge threshold, $3: battery, 
	local bat bdir start_thresh stop_thresh

	# check prerequisites: tp-smapi 
	if [ ! -d $SMAPIDIR ]; then
		echo_debug "pm" "fullcharge_battery.nosmapi: $bat"
		echo "Error: ThinkPad battery functions not available (missing tp_smapi kernel module)."
		return 1
	fi

	# check prerequisites: must be on ac power
	if ! get_power_state ; then
		echo_debug "pm" "setcharge_battery.noacpower: $bat"
		echo "Error: setting charge thresholds is possible on ac power only."
		return 1
	fi	

	# select battery and check if it is present
	bat=$3
	bat=${bat:=BAT0} # default is BAT0
	bat=$(echo $bat | tr "[:lower:]" "[:upper:]")
	bdir=$SMAPIDIR/$bat
	
	if [ ! -f $bdir/installed ] || [ "$(cat $bdir/installed)" = "0" ]; then
		echo "Error: battery $bat not present."
		echo_debug "pm" "setcharge_battery.notpresent: $bat"
		return 1
	fi
	
	# get thresholds args and check if they're valid
	thresh_check $1; start_thresh=$?
	thresh_check $2; stop_thresh=$?
		
	# check if > 0 and stop > start	
	if [ $start_thresh -eq 0 -o $stop_thresh -eq 0 -o $start_thresh -ge $stop_thresh ]; then
		echo "Error: invalid thresholds (start=$1, stop=$2)"		
		echo_debug "pm" "setcharge_battery.invalid_thresh: $bat \"$1\" \"$2\""
		return 1
	fi

	# set thresholds 
	echo_debug "pm" "setcharge_battery: $bat $start_thresh $stop_thresh"
	do_threshold $bdir/start_charge_thresh "$start_thresh"
	do_threshold $bdir/stop_charge_thresh "$stop_thresh"
	
	# trigger charging via discharge
	echo 1 > $bdir/force_discharge
	sleep 2
	echo 0 > $bdir/force_discharge
	
	echo "Charging thresholds of battery $bat temporarily set to $start_thresh $stop_thresh."
	echo_debug "pm" "setcharge_battery.initiated: $bat $start_thresh $stop_thresh"
	return 0
}

poweroff_drivebay () { # $1: 0=conditional+quiet mode, 1=force+verbose mode
	# Some code adapted from http://www.thinkwiki.org/wiki/How_to_hotswap_UltraBay_devices
	local dock optdrv syspath
	
	# Run only if either explicitly enabled or forced 
	[ "$BAY_POWEROFF_ON_BAT" = "1" ] || [ "$1" = "1" ] || return 0

	# Find generic dock interface for bay
	dock=$(grep -l ata_bay /sys/devices/platform/dock.?/type)
	dock=${dock%%/type}
	if [ -z "$dock" -o ! -d "$dock" ]; then
		echo_debug "pm" "poweroff_drivebay.nobaydevice"
		[ "$1" = "1" ] && echo "Error: cannot locate bay device."
		return 1
	fi
	echo_debug "pm" "poweroff_drivebay: dock=$dock"

	# Check if bay is occupied
	if [ $(cat $dock/docked) = "0" ]; then
		echo_debug "pm" "poweroff_drivebay.drivealreadyoff"
		[ "$1" = "1" ] && echo "No drive in bay (or power already off)."
	else 
		# Check for optical drive
		optdrv=/dev/${BAY_DEVICE:=sr0}
		if [ ! -b "$optdrv" ]; then
			echo_debug "pm" "poweroff_drivebay.nooptdrive: $optdrv"
			[ "$1" = "1" ] && echo "No optical drive in bay ($optdrv)."
			return 0
		else
			echo_debug "pm" "poweroff_drivebay: optdrv=$optdrv"
			
			# Unmount media 
			umount -l $optdrv > /dev/null 2>&1
			
			# Power off drive
			$HDPARM -Y $optdrv > /dev/null 2>&1
			sleep 1
	
			# Unregister scsi device
			syspath="/sys$($UDEVADM info --query=path --name=$optdrv | perl -pe 's!/block/...$!!')"
			echo_debug "pm" "poweroff_drivebay: syspath=$syspath"
			[ -n "$syspath" ] && echo 1 > $syspath/delete

			# Turn power off
			echo 1 > $dock/undock
			[ "$1" = "1" ] && echo "Bay is powered off now."
			echo_debug "pm" "poweroff_drivebay.baypoweredoff"
		fi
	fi
	
	return 0
}

